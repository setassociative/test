// The assert package include various simple test assertions
package assert

import (
	"encoding/json"
	"fmt"
	"os"
	"reflect"
	"regexp"
	"strings"
	"testing"

	"github.com/turbinelabs/tbn/test/check"
	"github.com/turbinelabs/tbn/test/stack"
)

const goPath = "/usr/local/"

// G represents a (possibly nested) group of assertions. The `Name`
// field is used as a prefix to the error message generated by each
// assertion.
type G struct {
	Name string
	T    testing.TB
}

// Creates a group of assertions with a common error message
// prefix. The prefix holds only for assertion methods invoked on the
// `G` instance passed to the given function:
//
// func TestThing(t *testing.T) {
//         Group("group-name", t, func(g *assert.G) {
//                 g.AssertTrue(true)
//         })
// }
//
// Note that `testing.TB` is an interface implemented by `testing.T`.
func Group(name string, t testing.TB, f func(*G)) {
	group := G{name, t}
	f(&group)
}

// Creates a nested group of assertions with a common error message
// prefix. The parent group's `Name` and the given `name` are joined
// with a space separator to form the prefix for the new group. The
// prefix holds only for assertion methods invoked on the `G` instance
// passed to this given function:
//
// func TestThing(t *testing.T) {
//         Group("group-name", t, func(g *assert.G) {
//                 g.Group("nested-group-name", func(ng *assert.G) {
//                         ng.AssertTrue(true)
//                 })
//         })
// }
func (grp *G) Group(name string, f func(*G)) {
	nestedName := fmt.Sprintf("%s %s", grp.Name, name)
	nestedGrp := G{nestedName, grp.T}
	f(&nestedGrp)
}

func defaultGroup(t testing.TB) *G {
	return &G{"", t}
}

func stackTrace() string {
	tbnPath := os.Getenv("TBN_FULL_HOME") + "/"

	trace := stack.New()
	if tbnPath != "/" {
		trace.TrimPaths(tbnPath, goPath)
	}

	trace.PopFrames("test/")

	return "\n" + trace.Format(true)
}

func Nil(t testing.TB, got interface{}) bool {
	return defaultGroup(t).AssertNil(got)
}

func NonNil(t testing.TB, got interface{}) bool {
	return defaultGroup(t).AssertNonNil(got)
}

func Equal(t testing.TB, got, want interface{}) bool {
	return defaultGroup(t).AssertEqual(got, want)
}

func NotEqual(t testing.TB, got, want interface{}) bool {
	return defaultGroup(t).AssertNotEqual(got, want)
}

func DeepEqual(t testing.TB, got, want interface{}) bool {
	return defaultGroup(t).AssertDeepEqual(got, want)
}

func NotDeepEqual(t testing.TB, got, want interface{}) bool {
	return defaultGroup(t).AssertNotDeepEqual(got, want)
}

func EqualJson(t testing.TB, got, want interface{}) bool {
	return defaultGroup(t).AssertEqualJson(got, want)
}

func NotEqualJson(t testing.TB, got, want interface{}) bool {
	return defaultGroup(t).AssertNotEqualJson(got, want)
}

func MatchesRegex(t testing.TB, got, wantRegex string) bool {
	return defaultGroup(t).AssertMatchesRegex(got, wantRegex)
}

func DoesNotMatchRegex(t testing.TB, got, wantRegex string) bool {
	return defaultGroup(t).AssertDoesNotMatchRegex(got, wantRegex)
}

func True(t testing.TB, value bool) bool {
	return defaultGroup(t).AssertTrue(value)
}

func False(t testing.TB, value bool) bool {
	return defaultGroup(t).AssertFalse(value)
}

func ErrorContains(t testing.TB, got error, want string) bool {
	return defaultGroup(t).AssertErrorContains(got, want)
}

func ErrorDoesNotContain(t testing.TB, got error, want string) bool {
	return defaultGroup(t).AssertErrorDoesNotContain(got, want)
}

// Compares two container-like values. The `got` parameter may be an
// array, slice, or channel. The `want` parameter must be an array or
// slice whose element type is the same as that of `got`. If `got` is
// a channel, all available values are consumed (until the channel
// either blocks or indicates it was closed). The `got` and `want`
// values are then compared without respect to order.
func HasSameElements(t testing.TB, got, want interface{}) bool {
	return defaultGroup(t).AssertHasSameElements(got, want)
}

// G methods

func (grp *G) Errorf(format string, args ...interface{}) {
	if len(grp.Name) > 0 {
		prefix := fmt.Sprintf("%s: ", grp.Name)
		format = prefix + format
	}

	grp.T.Errorf(format, args...)
}

func (grp *G) Fatalf(format string, args ...interface{}) {
	if len(grp.Name) > 0 {
		prefix := fmt.Sprintf("%s: ", grp.Name)
		format = prefix + format
	}

	grp.T.Fatalf(format, args...)
}

func (grp *G) AssertNil(got interface{}) bool {
	if !check.IsNil(got) {
		grp.Errorf("got (%T) %+v, want <nil> in %s", got, got, stackTrace())
		return false
	}
	return true
}

func (grp *G) AssertNonNil(got interface{}) bool {
	if check.IsNil(got) {
		grp.Errorf("got (%T) %+v, want <non-nil> in %s", got, got, stackTrace())
		return false
	}
	return true
}

func (grp *G) AssertEqual(got, want interface{}) bool {
	if got != want {
		grp.Errorf("got: (%T) %+v, want (%T) %+v in %s", got, got, want, want, stackTrace())
		return false
	}
	return true
}

func (grp *G) AssertNotEqual(got, want interface{}) bool {
	if got == want {
		grp.Errorf("got: (%T) %+v, want != (%T) %+v in %s", got, got, want, want, stackTrace())
		return false
	}
	return true
}

func (grp *G) AssertDeepEqual(got, want interface{}) bool {
	if !reflect.DeepEqual(got, want) {
		grp.Errorf("got: (%T) %+v, want (%T) %+v in %s", got, got, want, want, stackTrace())
		return false
	}
	return true
}

func (grp *G) AssertNotDeepEqual(got, want interface{}) bool {
	if reflect.DeepEqual(got, want) {
		grp.Errorf("got: (%T) %+v, want != (%T) %+v in %s", got, got, want, want, stackTrace())
		return false
	}
	return true
}

func (grp *G) encodeJson(got, want interface{}) (string, string) {
	gotJson, err := json.Marshal(got)
	if err != nil {
		grp.Fatalf("could not marshal json: %+v in %s", err, stackTrace())
	}
	wantJson, err := json.Marshal(want)
	if err != nil {
		grp.Fatalf("could not marshal json: %+v in %s", err, stackTrace())
	}
	return string(gotJson), string(wantJson)
}

func (grp *G) AssertEqualJson(got, want interface{}) bool {
	gotJson, wantJson := grp.encodeJson(got, want)
	return grp.AssertEqual(gotJson, wantJson)
}

func (grp *G) AssertNotEqualJson(got, want interface{}) bool {
	gotJson, wantJson := grp.encodeJson(got, want)
	return grp.AssertNotEqual(gotJson, wantJson)
}

func (grp *G) matchRegex(got, wantRegex string) bool {
	matched, err := regexp.MatchString(wantRegex, got)
	if err != nil {
		grp.Fatalf(
			"invalid regular expression `%s`: %+v in %s",
			wantRegex,
			err,
			stackTrace())
	}

	return matched
}

func (grp *G) AssertMatchesRegex(got, wantRegex string) bool {
	if !grp.matchRegex(got, wantRegex) {
		grp.Errorf("got %s, did not match `%s` in %s", got, wantRegex, stackTrace())
		return false
	}

	return true
}

func (grp *G) AssertDoesNotMatchRegex(got, wantRegex string) bool {
	if grp.matchRegex(got, wantRegex) {
		grp.Errorf("got %s, matched `%s` in %s", got, wantRegex, stackTrace())
		return false
	}

	return true
}

func (grp *G) AssertTrue(value bool) bool {
	return grp.AssertEqual(value, true)
}

func (grp *G) AssertFalse(value bool) bool {
	return grp.AssertEqual(value, false)
}

func (grp *G) AssertErrorContains(got error, want string) bool {
	if got == nil {
		grp.Errorf(
			"got nil error, wanted message containing `%s` in %s",
			want,
			stackTrace())
		return false
	} else if !strings.Contains(got.Error(), want) {
		grp.Errorf(
			"got error `%s`, wanted message containing `%s` in %s",
			got.Error(),
			want,
			stackTrace())
		return false
	}

	return true
}

func (grp *G) AssertErrorDoesNotContain(got error, want string) bool {
	if got == nil {
		grp.Errorf(
			"got nil error, wanted message not containing `%s` in %s",
			want,
			stackTrace())
		return false
	} else if strings.Contains(got.Error(), want) {
		grp.Errorf(
			"got error `%s`, wanted message not containing `%s` in %s",
			got.Error(),
			want,
			stackTrace())
		return false
	}

	return true
}

func (grp *G) checkContainerTypes(gotType, wantType reflect.Type) bool {
	gotKind := gotType.Kind()
	wantKind := wantType.Kind()

	switch gotKind {
	case reflect.Array, reflect.Slice:
		// ok

	case reflect.Chan:
		if gotType.ChanDir()&reflect.RecvDir == 0 {
			grp.Errorf(
				"got type '%v', a non-receiving channel in %s",
				gotType,
				stackTrace())
			return false
		}

	default:
		grp.Errorf(
			"got type '%v', can only compare arrays, slices, or channels in %s",
			gotType,
			stackTrace())
		return false
	}

	if wantKind != reflect.Array && wantKind != reflect.Slice {
		// We only compare with Array/Slices
		grp.Errorf(
			"got type '%v', want type must be an array or slice of %s, not '%v' in %s",
			gotType,
			gotType.Elem(),
			wantType,
			stackTrace())
		return false
	}

	// The Array/Slice/Chan element types must match
	if gotType.Elem() != wantType.Elem() {
		grp.Errorf(
			"got type '%v', wanted type '%v': contains types do not match in %s",
			gotType,
			wantType,
			stackTrace())
		return false
	}

	return true
}

func (grp *G) assertSameArray(gotValue, wantValue []reflect.Value) string {
	gotLen := len(gotValue)
	wantLen := len(wantValue)

	unusedGotIndicies := make([]int, gotLen)
	for i := 0; i < gotLen; i++ {
		unusedGotIndicies[i] = i
	}

	unusedWantIndicies := make([]int, wantLen)
	for i := 0; i < wantLen; i++ {
		unusedWantIndicies[i] = i
	}

	for gotIndex, v := range gotValue {
		for _, wantIndex := range unusedWantIndicies {
			if wantIndex != -1 {
				w := wantValue[wantIndex]
				if reflect.DeepEqual(v.Interface(), w.Interface()) {
					unusedWantIndicies[wantIndex] = -1
					unusedGotIndicies[gotIndex] = -1
					break
				}
			}
		}
	}

	extra := []interface{}{}
	for _, gotIndex := range unusedGotIndicies {
		if gotIndex != -1 {
			extra = append(extra, gotValue[gotIndex].Interface())
		}
	}

	missing := []interface{}{}
	for _, wantIndex := range unusedWantIndicies {
		if wantIndex != -1 {
			missing = append(missing, wantValue[wantIndex].Interface())
		}
	}

	if gotLen != wantLen || len(extra) > 0 || len(missing) > 0 {
		missingStr := ""
		if len(missing) > 0 {
			missingStr = fmt.Sprintf("; missing elements: %v", missing)
		}

		extraStr := ""
		if len(extra) > 0 {
			extraStr = fmt.Sprintf("; extra elements: %v", extra)
		}

		return fmt.Sprintf(
			"got %v (len %d), wanted %v (len %d)%s%s in %s",
			gotValue,
			gotLen,
			wantValue,
			wantLen,
			missingStr,
			extraStr,
			stackTrace())
	}

	return ""
}

// See `HasSameElements`.
func (grp *G) AssertHasSameElements(got, want interface{}) bool {
	gotType := reflect.TypeOf(got)
	wantType := reflect.TypeOf(want)
	if !grp.checkContainerTypes(gotType, wantType) {
		return false
	}

	gotValue := reflect.ValueOf(got)
	wantValue := reflect.ValueOf(want)

	wantValueArray := make([]reflect.Value, wantValue.Len())
	for i := 0; i < wantValue.Len(); i++ {
		wantValueArray[i] = wantValue.Index(i)
	}

	var msg string
	switch gotType.Kind() {
	case reflect.Array, reflect.Slice:
		gotValueArray := make([]reflect.Value, gotValue.Len())
		for i := 0; i < gotValue.Len(); i++ {
			gotValueArray[i] = gotValue.Index(i)
		}
		msg = grp.assertSameArray(gotValueArray, wantValueArray)

	case reflect.Chan:
		gotValueArray := []reflect.Value{}
		for {
			v, ok := gotValue.TryRecv()
			if !ok {
				// blocked or closed
				break
			}
			gotValueArray = append(gotValueArray, v)
		}
		msg = grp.assertSameArray(gotValueArray, wantValueArray)

	default:
		msg = fmt.Sprintf(
			"internal error: unexpected kind %v in %s",
			gotType.Kind(),
			stackTrace())
	}

	if msg != "" {
		grp.Errorf(msg)
		return false
	}

	return true
}
